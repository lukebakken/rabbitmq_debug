#!/usr/bin/env python3
import json
import pika
import random
import signal
import sys

rabbitmq_exchange = "rpc_flood"
node1 = pika.URLParameters('amqp://user:password@localhost:5672/')
node2 = pika.URLParameters('amqp://user:password@localhost:5673/')
node3 = pika.URLParameters('amqp://user:password@localhost:5674/')
all_endpoints = [node1, node2, node3]

#
# MAIN
#

kill_now = False
connection = None

def recv_callback(ch, method, properties, body):
    if kill_now:
        ch.stop_consuming();
        ch.close();
        connection.close();
        sys.exit(0)
    else:
        print("Got Request:" + str(body))
        try:
            request = json.loads(body)
            reply_key = request['routing_key']
            data = { 'msg': 'have a nice day' }
            json_string = json.dumps(data)
            channel.basic_publish(exchange=reply_key, routing_key=reply_key, body=json_string)
            print(" [x] Sent " + json_string + " to exchange " + reply_key)
        except Exception as e:
            print("ERR - %s" % e)

while True:
    try:
        random.shuffle(all_endpoints)
        # RabbitMQ Connection
        connection = pika.BlockingConnection(all_endpoints[0])
        channel = connection.channel()

        if kill_now:
            channel.close();
            connection.close();
            sys.exit(0)

        channel.exchange_declare(exchange=rabbitmq_exchange, exchange_type='topic', durable=True, auto_delete=False)
        result = channel.queue_declare(rabbitmq_exchange + '_control', durable=True, auto_delete=False)
        queue_name = result.method.queue
        print(queue_name)
        channel.queue_bind(exchange=rabbitmq_exchange, queue=queue_name, routing_key='control')

        channel.basic_consume(queue_name, recv_callback, auto_ack=True)
        print(' [*] Waiting for messages. To exit press CTRL+C')
        channel.start_consuming()


#    except pika.exceptions.ConnectionClosedByBroker:
#        # Uncomment this to make the example not attempt recovery
#        # from server-initiated connection closure, including
#        # when the node is stopped cleanly
#        #
#        # break
#        continue
    # Do not recover on channel errors
    except pika.exceptions.AMQPChannelError as err:
        print("Caught a channel error: {}, stopping...".format(err))
        break
    # Recover on all other connection errors
    except pika.exceptions.AMQPConnectionError:
        secs = random.randint(1,5)
        print("Connection was closed, retrying in {} seconds...".format(secs))
        time.sleep(secs)
        continue
